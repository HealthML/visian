/* tslint:disable */
/* eslint-disable */
/**
 * Annotation Service
 * A service to make medical image annotation as enjoyable as possible.
 *
 * OpenAPI spec version: 0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, {
  AxiosResponse,
  AxiosInstance,
  AxiosRequestConfig,
} from "axios";
import { Configuration } from "../configuration";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "../base";
import { Annotation } from "../models";
import { DeleteAllDto } from "../models";
/**
 * AnnotationsApi - axios parameter creator
 * @export
 */
export const AnnotationsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Creates a new annotation and returns it. Additionally it saves the optional file passed to this endpoint under the annotation's dataUri. An error will be thrown if the referenced image does not exist. Trying to create an annotation with the same data URI as an already existing annotation will also result in an error.
     * @param {string} image
     * @param {string} job
     * @param {string} dataUri
     * @param {boolean} verified
     * @param {Blob} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    annotationsControllerCreateForm: async (
      image: string,
      job: string,
      dataUri: string,
      verified: boolean,
      file: Blob,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'image' is not null or undefined
      if (image === null || image === undefined) {
        throw new RequiredError(
          "image",
          "Required parameter image was null or undefined when calling annotationsControllerCreateForm.",
        );
      }
      // verify required parameter 'job' is not null or undefined
      if (job === null || job === undefined) {
        throw new RequiredError(
          "job",
          "Required parameter job was null or undefined when calling annotationsControllerCreateForm.",
        );
      }
      // verify required parameter 'dataUri' is not null or undefined
      if (dataUri === null || dataUri === undefined) {
        throw new RequiredError(
          "dataUri",
          "Required parameter dataUri was null or undefined when calling annotationsControllerCreateForm.",
        );
      }
      // verify required parameter 'verified' is not null or undefined
      if (verified === null || verified === undefined) {
        throw new RequiredError(
          "verified",
          "Required parameter verified was null or undefined when calling annotationsControllerCreateForm.",
        );
      }
      // verify required parameter 'file' is not null or undefined
      if (file === null || file === undefined) {
        throw new RequiredError(
          "file",
          "Required parameter file was null or undefined when calling annotationsControllerCreateForm.",
        );
      }
      const localVarPath = `/annotations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new FormData();

      if (image !== undefined) {
        localVarFormParams.append("image", image as any);
      }

      if (job !== undefined) {
        localVarFormParams.append("job", job as any);
      }

      if (dataUri !== undefined) {
        localVarFormParams.append("dataUri", dataUri as any);
      }

      if (verified !== undefined) {
        localVarFormParams.append("verified", verified as any);
      }

      if (file !== undefined) {
        localVarFormParams.append("file", file as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";
      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves a list of all available annotations. If there do not exist any annotations it will return an empty array. If an image or job is specified, it will return all annotations belonging to the image (if specified) and generated by the job (if specified). If the image or job does not exist it will return an empty array.
     * @param {string} [image] The image identifier (uuid) to filter the annotations by.
     * @param {string} [job] The job identifier (uuid) to filter the annotations by.
     * @param {any} [verified] If set to true, only human-verified annotations are returned. When set to false, non-verified annotations are returned. If no value is provided, all annotations are returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    annotationsControllerFindAll: async (
      image?: string,
      job?: string,
      verified?: any,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/annotations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (image !== undefined) {
        localVarQueryParameter["image"] = image;
      }

      if (job !== undefined) {
        localVarQueryParameter["job"] = job;
      }

      if (verified !== undefined) {
        localVarQueryParameter["verified"] = verified;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves an annotation, if a valid identifier was provided. Otherwise it returns an error.
     * @param {string} id The identifier (uuid) of the annotation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    annotationsControllerFindOne: async (
      id: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling annotationsControllerFindOne.",
        );
      }
      const localVarPath = `/annotations/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the file for an annotation.
     * @param {string} id The identifier (uuid) of the annotation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    annotationsControllerGetFile: async (
      id: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling annotationsControllerGetFile.",
        );
      }
      const localVarPath = `/annotations/{id}/file`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes an annotation permanently. It cannot be undone. It does not delete associated images or jobs. It returns an error if the annotation can not be found or the delete operation fails.
     * @param {string} id The identifier (uuid) of the annotation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    annotationsControllerRemove: async (
      id: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling annotationsControllerRemove.",
        );
      }
      const localVarPath = `/annotations/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes all selected annotations permanently. It cannot be undone. It returns the annotations that were deleted.
     * @param {DeleteAllDto} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    annotationsControllerRemoveAll: async (
      body: DeleteAllDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling annotationsControllerRemoveAll.",
        );
      }
      const localVarPath = `/annotations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates the specified annotation by setting the values of the parameters passed. Additionally it saves the optional file passed to this endpoint under the annotation's (new) dataUri. All parameters not provided will be left unchanged. It returns the updated annotation, if the update operation succeeds. Otherwise it returns an error. When changing the dataUri, the old file won't be deleted automatically.
     * @param {string} dataUri
     * @param {boolean} verified
     * @param {Blob} file
     * @param {string} id The identifier (uuid) of the annotation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    annotationsControllerUpdateForm: async (
      dataUri: string,
      verified: boolean,
      file: Blob,
      id: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'dataUri' is not null or undefined
      if (dataUri === null || dataUri === undefined) {
        throw new RequiredError(
          "dataUri",
          "Required parameter dataUri was null or undefined when calling annotationsControllerUpdateForm.",
        );
      }
      // verify required parameter 'verified' is not null or undefined
      if (verified === null || verified === undefined) {
        throw new RequiredError(
          "verified",
          "Required parameter verified was null or undefined when calling annotationsControllerUpdateForm.",
        );
      }
      // verify required parameter 'file' is not null or undefined
      if (file === null || file === undefined) {
        throw new RequiredError(
          "file",
          "Required parameter file was null or undefined when calling annotationsControllerUpdateForm.",
        );
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling annotationsControllerUpdateForm.",
        );
      }
      const localVarPath = `/annotations/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new FormData();

      if (dataUri !== undefined) {
        localVarFormParams.append("dataUri", dataUri as any);
      }

      if (verified !== undefined) {
        localVarFormParams.append("verified", verified as any);
      }

      if (file !== undefined) {
        localVarFormParams.append("file", file as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";
      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AnnotationsApi - functional programming interface
 * @export
 */
export const AnnotationsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Creates a new annotation and returns it. Additionally it saves the optional file passed to this endpoint under the annotation's dataUri. An error will be thrown if the referenced image does not exist. Trying to create an annotation with the same data URI as an already existing annotation will also result in an error.
     * @param {string} image
     * @param {string} job
     * @param {string} dataUri
     * @param {boolean} verified
     * @param {Blob} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async annotationsControllerCreateForm(
      image: string,
      job: string,
      dataUri: string,
      verified: boolean,
      file: Blob,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<Annotation>>
    > {
      const localVarAxiosArgs = await AnnotationsApiAxiosParamCreator(
        configuration,
      ).annotationsControllerCreateForm(
        image,
        job,
        dataUri,
        verified,
        file,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves a list of all available annotations. If there do not exist any annotations it will return an empty array. If an image or job is specified, it will return all annotations belonging to the image (if specified) and generated by the job (if specified). If the image or job does not exist it will return an empty array.
     * @param {string} [image] The image identifier (uuid) to filter the annotations by.
     * @param {string} [job] The job identifier (uuid) to filter the annotations by.
     * @param {any} [verified] If set to true, only human-verified annotations are returned. When set to false, non-verified annotations are returned. If no value is provided, all annotations are returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async annotationsControllerFindAll(
      image?: string,
      job?: string,
      verified?: any,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<Array<Annotation>>>
    > {
      const localVarAxiosArgs = await AnnotationsApiAxiosParamCreator(
        configuration,
      ).annotationsControllerFindAll(image, job, verified, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves an annotation, if a valid identifier was provided. Otherwise it returns an error.
     * @param {string} id The identifier (uuid) of the annotation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async annotationsControllerFindOne(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<Annotation>>
    > {
      const localVarAxiosArgs = await AnnotationsApiAxiosParamCreator(
        configuration,
      ).annotationsControllerFindOne(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Returns the file for an annotation.
     * @param {string} id The identifier (uuid) of the annotation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async annotationsControllerGetFile(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Blob>>
    > {
      const localVarAxiosArgs = await AnnotationsApiAxiosParamCreator(
        configuration,
      ).annotationsControllerGetFile(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Deletes an annotation permanently. It cannot be undone. It does not delete associated images or jobs. It returns an error if the annotation can not be found or the delete operation fails.
     * @param {string} id The identifier (uuid) of the annotation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async annotationsControllerRemove(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await AnnotationsApiAxiosParamCreator(
        configuration,
      ).annotationsControllerRemove(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Deletes all selected annotations permanently. It cannot be undone. It returns the annotations that were deleted.
     * @param {DeleteAllDto} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async annotationsControllerRemoveAll(
      body: DeleteAllDto,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await AnnotationsApiAxiosParamCreator(
        configuration,
      ).annotationsControllerRemoveAll(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Updates the specified annotation by setting the values of the parameters passed. Additionally it saves the optional file passed to this endpoint under the annotation's (new) dataUri. All parameters not provided will be left unchanged. It returns the updated annotation, if the update operation succeeds. Otherwise it returns an error. When changing the dataUri, the old file won't be deleted automatically.
     * @param {string} dataUri
     * @param {boolean} verified
     * @param {Blob} file
     * @param {string} id The identifier (uuid) of the annotation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async annotationsControllerUpdateForm(
      dataUri: string,
      verified: boolean,
      file: Blob,
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<Annotation>>
    > {
      const localVarAxiosArgs = await AnnotationsApiAxiosParamCreator(
        configuration,
      ).annotationsControllerUpdateForm(dataUri, verified, file, id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * AnnotationsApi - factory interface
 * @export
 */
export const AnnotationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     * Creates a new annotation and returns it. Additionally it saves the optional file passed to this endpoint under the annotation's dataUri. An error will be thrown if the referenced image does not exist. Trying to create an annotation with the same data URI as an already existing annotation will also result in an error.
     * @param {string} image
     * @param {string} job
     * @param {string} dataUri
     * @param {boolean} verified
     * @param {Blob} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async annotationsControllerCreateForm(
      image: string,
      job: string,
      dataUri: string,
      verified: boolean,
      file: Blob,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Annotation>> {
      return AnnotationsApiFp(configuration)
        .annotationsControllerCreateForm(
          image,
          job,
          dataUri,
          verified,
          file,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves a list of all available annotations. If there do not exist any annotations it will return an empty array. If an image or job is specified, it will return all annotations belonging to the image (if specified) and generated by the job (if specified). If the image or job does not exist it will return an empty array.
     * @param {string} [image] The image identifier (uuid) to filter the annotations by.
     * @param {string} [job] The job identifier (uuid) to filter the annotations by.
     * @param {any} [verified] If set to true, only human-verified annotations are returned. When set to false, non-verified annotations are returned. If no value is provided, all annotations are returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async annotationsControllerFindAll(
      image?: string,
      job?: string,
      verified?: any,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Array<Annotation>>> {
      return AnnotationsApiFp(configuration)
        .annotationsControllerFindAll(image, job, verified, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves an annotation, if a valid identifier was provided. Otherwise it returns an error.
     * @param {string} id The identifier (uuid) of the annotation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async annotationsControllerFindOne(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Annotation>> {
      return AnnotationsApiFp(configuration)
        .annotationsControllerFindOne(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns the file for an annotation.
     * @param {string} id The identifier (uuid) of the annotation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async annotationsControllerGetFile(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Blob>> {
      return AnnotationsApiFp(configuration)
        .annotationsControllerGetFile(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes an annotation permanently. It cannot be undone. It does not delete associated images or jobs. It returns an error if the annotation can not be found or the delete operation fails.
     * @param {string} id The identifier (uuid) of the annotation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async annotationsControllerRemove(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      return AnnotationsApiFp(configuration)
        .annotationsControllerRemove(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes all selected annotations permanently. It cannot be undone. It returns the annotations that were deleted.
     * @param {DeleteAllDto} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async annotationsControllerRemoveAll(
      body: DeleteAllDto,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      return AnnotationsApiFp(configuration)
        .annotationsControllerRemoveAll(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates the specified annotation by setting the values of the parameters passed. Additionally it saves the optional file passed to this endpoint under the annotation's (new) dataUri. All parameters not provided will be left unchanged. It returns the updated annotation, if the update operation succeeds. Otherwise it returns an error. When changing the dataUri, the old file won't be deleted automatically.
     * @param {string} dataUri
     * @param {boolean} verified
     * @param {Blob} file
     * @param {string} id The identifier (uuid) of the annotation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async annotationsControllerUpdateForm(
      dataUri: string,
      verified: boolean,
      file: Blob,
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Annotation>> {
      return AnnotationsApiFp(configuration)
        .annotationsControllerUpdateForm(dataUri, verified, file, id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AnnotationsApi - object-oriented interface
 * @export
 * @class AnnotationsApi
 * @extends {BaseAPI}
 */
export class AnnotationsApi extends BaseAPI {
  /**
   * Creates a new annotation and returns it. Additionally it saves the optional file passed to this endpoint under the annotation's dataUri. An error will be thrown if the referenced image does not exist. Trying to create an annotation with the same data URI as an already existing annotation will also result in an error.
   * @param {string} image
   * @param {string} job
   * @param {string} dataUri
   * @param {boolean} verified
   * @param {Blob} file
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AnnotationsApi
   */
  public async annotationsControllerCreateForm(
    image: string,
    job: string,
    dataUri: string,
    verified: boolean,
    file: Blob,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Annotation>> {
    return AnnotationsApiFp(this.configuration)
      .annotationsControllerCreateForm(
        image,
        job,
        dataUri,
        verified,
        file,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves a list of all available annotations. If there do not exist any annotations it will return an empty array. If an image or job is specified, it will return all annotations belonging to the image (if specified) and generated by the job (if specified). If the image or job does not exist it will return an empty array.
   * @param {string} [image] The image identifier (uuid) to filter the annotations by.
   * @param {string} [job] The job identifier (uuid) to filter the annotations by.
   * @param {any} [verified] If set to true, only human-verified annotations are returned. When set to false, non-verified annotations are returned. If no value is provided, all annotations are returned.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AnnotationsApi
   */
  public async annotationsControllerFindAll(
    image?: string,
    job?: string,
    verified?: any,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Array<Annotation>>> {
    return AnnotationsApiFp(this.configuration)
      .annotationsControllerFindAll(image, job, verified, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves an annotation, if a valid identifier was provided. Otherwise it returns an error.
   * @param {string} id The identifier (uuid) of the annotation.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AnnotationsApi
   */
  public async annotationsControllerFindOne(
    id: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Annotation>> {
    return AnnotationsApiFp(this.configuration)
      .annotationsControllerFindOne(id, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Returns the file for an annotation.
   * @param {string} id The identifier (uuid) of the annotation.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AnnotationsApi
   */
  public async annotationsControllerGetFile(
    id: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Blob>> {
    return AnnotationsApiFp(this.configuration)
      .annotationsControllerGetFile(id, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes an annotation permanently. It cannot be undone. It does not delete associated images or jobs. It returns an error if the annotation can not be found or the delete operation fails.
   * @param {string} id The identifier (uuid) of the annotation.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AnnotationsApi
   */
  public async annotationsControllerRemove(
    id: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<void>> {
    return AnnotationsApiFp(this.configuration)
      .annotationsControllerRemove(id, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes all selected annotations permanently. It cannot be undone. It returns the annotations that were deleted.
   * @param {DeleteAllDto} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AnnotationsApi
   */
  public async annotationsControllerRemoveAll(
    body: DeleteAllDto,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<void>> {
    return AnnotationsApiFp(this.configuration)
      .annotationsControllerRemoveAll(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Updates the specified annotation by setting the values of the parameters passed. Additionally it saves the optional file passed to this endpoint under the annotation's (new) dataUri. All parameters not provided will be left unchanged. It returns the updated annotation, if the update operation succeeds. Otherwise it returns an error. When changing the dataUri, the old file won't be deleted automatically.
   * @param {string} dataUri
   * @param {boolean} verified
   * @param {Blob} file
   * @param {string} id The identifier (uuid) of the annotation.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AnnotationsApi
   */
  public async annotationsControllerUpdateForm(
    dataUri: string,
    verified: boolean,
    file: Blob,
    id: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Annotation>> {
    return AnnotationsApiFp(this.configuration)
      .annotationsControllerUpdateForm(dataUri, verified, file, id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
