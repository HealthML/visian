/* tslint:disable */
/* eslint-disable */
/**
 * Annotation Service
 * A service to make medical image annotation as enjoyable as possible.
 *
 * OpenAPI spec version: 0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, {
  AxiosResponse,
  AxiosInstance,
  AxiosRequestConfig,
} from "axios";
import { Configuration } from "../configuration";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "../base";
import { DeleteAllDto } from "../models";
import { Image } from "../models";
/**
 * ImagesApi - axios parameter creator
 * @export
 */
export const ImagesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Creates a new image and returns it. Additionally it saves the optional file passed to this endpoint under the image's dataUri. An error will be thrown if the referenced dataset does not exist. Trying to create an image with the same data URI as an already existing image will also result in an error.
     * @param {string} dataset
     * @param {string} dataUri
     * @param {Blob} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesControllerCreateForm: async (
      dataset: string,
      dataUri: string,
      file: Blob,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'dataset' is not null or undefined
      if (dataset === null || dataset === undefined) {
        throw new RequiredError(
          "dataset",
          "Required parameter dataset was null or undefined when calling imagesControllerCreateForm.",
        );
      }
      // verify required parameter 'dataUri' is not null or undefined
      if (dataUri === null || dataUri === undefined) {
        throw new RequiredError(
          "dataUri",
          "Required parameter dataUri was null or undefined when calling imagesControllerCreateForm.",
        );
      }
      // verify required parameter 'file' is not null or undefined
      if (file === null || file === undefined) {
        throw new RequiredError(
          "file",
          "Required parameter file was null or undefined when calling imagesControllerCreateForm.",
        );
      }
      const localVarPath = `/images`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new FormData();

      if (dataset !== undefined) {
        localVarFormParams.append("dataset", dataset as any);
      }

      if (dataUri !== undefined) {
        localVarFormParams.append("dataUri", dataUri as any);
      }

      if (file !== undefined) {
        localVarFormParams.append("file", file as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";
      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves a list of all available images. If there do not exist any images it will return an empty array. If a dataset or job is specified, it will return all images in the dataset or used by the job. If the dataset or job does not exist it will return an empty array.
     * @param {string} [dataset] The dataset identifier (uuid) to filter the images by.
     * @param {string} [job] The job identifier (uuid) to filter the images by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesControllerFindAll: async (
      dataset?: string,
      job?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/images`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (dataset !== undefined) {
        localVarQueryParameter["dataset"] = dataset;
      }

      if (job !== undefined) {
        localVarQueryParameter["job"] = job;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves an image, if a valid identifier was provided. Otherwise it returns an error.
     * @param {string} id The identifier (uuid) of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesControllerFindOne: async (
      id: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling imagesControllerFindOne.",
        );
      }
      const localVarPath = `/images/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the file for an image.
     * @param {string} id The identifier (uuid) of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesControllerGetFile: async (
      id: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling imagesControllerGetFile.",
        );
      }
      const localVarPath = `/images/{id}/file`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes an image and associated annotations permanently. It cannot be undone. It returns an error if the image can not be found or the delete operation fails.
     * @param {string} id The identifier (uuid) of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesControllerRemove: async (
      id: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling imagesControllerRemove.",
        );
      }
      const localVarPath = `/images/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes all selected images and all associated annotations permanently. It cannot be undone. It returns the images that were deleted.
     * @param {DeleteAllDto} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesControllerRemoveAll: async (
      body: DeleteAllDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling imagesControllerRemoveAll.",
        );
      }
      const localVarPath = `/images`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates the specified image by setting the values of the parameters passed. Additionally it saves the optional file passed to this endpoint under the image's (new) dataUri. It returns the updated image, if the update operation succeeds. It returns an error when trying to set the image data URI to an already existing image data URI. When changing the dataUri, the old file won't be deleted automatically.
     * @param {string} dataUri
     * @param {Blob} file
     * @param {string} id The identifier (uuid) of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesControllerUpdateForm: async (
      dataUri: string,
      file: Blob,
      id: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'dataUri' is not null or undefined
      if (dataUri === null || dataUri === undefined) {
        throw new RequiredError(
          "dataUri",
          "Required parameter dataUri was null or undefined when calling imagesControllerUpdateForm.",
        );
      }
      // verify required parameter 'file' is not null or undefined
      if (file === null || file === undefined) {
        throw new RequiredError(
          "file",
          "Required parameter file was null or undefined when calling imagesControllerUpdateForm.",
        );
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling imagesControllerUpdateForm.",
        );
      }
      const localVarPath = `/images/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new FormData();

      if (dataUri !== undefined) {
        localVarFormParams.append("dataUri", dataUri as any);
      }

      if (file !== undefined) {
        localVarFormParams.append("file", file as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";
      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ImagesApi - functional programming interface
 * @export
 */
export const ImagesApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Creates a new image and returns it. Additionally it saves the optional file passed to this endpoint under the image's dataUri. An error will be thrown if the referenced dataset does not exist. Trying to create an image with the same data URI as an already existing image will also result in an error.
     * @param {string} dataset
     * @param {string} dataUri
     * @param {Blob} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesControllerCreateForm(
      dataset: string,
      dataUri: string,
      file: Blob,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<Image>>
    > {
      const localVarAxiosArgs = await ImagesApiAxiosParamCreator(
        configuration,
      ).imagesControllerCreateForm(dataset, dataUri, file, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves a list of all available images. If there do not exist any images it will return an empty array. If a dataset or job is specified, it will return all images in the dataset or used by the job. If the dataset or job does not exist it will return an empty array.
     * @param {string} [dataset] The dataset identifier (uuid) to filter the images by.
     * @param {string} [job] The job identifier (uuid) to filter the images by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesControllerFindAll(
      dataset?: string,
      job?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<Array<Image>>>
    > {
      const localVarAxiosArgs = await ImagesApiAxiosParamCreator(
        configuration,
      ).imagesControllerFindAll(dataset, job, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves an image, if a valid identifier was provided. Otherwise it returns an error.
     * @param {string} id The identifier (uuid) of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesControllerFindOne(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<Image>>
    > {
      const localVarAxiosArgs = await ImagesApiAxiosParamCreator(
        configuration,
      ).imagesControllerFindOne(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Returns the file for an image.
     * @param {string} id The identifier (uuid) of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesControllerGetFile(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Blob>>
    > {
      const localVarAxiosArgs = await ImagesApiAxiosParamCreator(
        configuration,
      ).imagesControllerGetFile(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Deletes an image and associated annotations permanently. It cannot be undone. It returns an error if the image can not be found or the delete operation fails.
     * @param {string} id The identifier (uuid) of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesControllerRemove(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await ImagesApiAxiosParamCreator(
        configuration,
      ).imagesControllerRemove(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Deletes all selected images and all associated annotations permanently. It cannot be undone. It returns the images that were deleted.
     * @param {DeleteAllDto} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesControllerRemoveAll(
      body: DeleteAllDto,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await ImagesApiAxiosParamCreator(
        configuration,
      ).imagesControllerRemoveAll(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Updates the specified image by setting the values of the parameters passed. Additionally it saves the optional file passed to this endpoint under the image's (new) dataUri. It returns the updated image, if the update operation succeeds. It returns an error when trying to set the image data URI to an already existing image data URI. When changing the dataUri, the old file won't be deleted automatically.
     * @param {string} dataUri
     * @param {Blob} file
     * @param {string} id The identifier (uuid) of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesControllerUpdateForm(
      dataUri: string,
      file: Blob,
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<Image>>
    > {
      const localVarAxiosArgs = await ImagesApiAxiosParamCreator(
        configuration,
      ).imagesControllerUpdateForm(dataUri, file, id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * ImagesApi - factory interface
 * @export
 */
export const ImagesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     * Creates a new image and returns it. Additionally it saves the optional file passed to this endpoint under the image's dataUri. An error will be thrown if the referenced dataset does not exist. Trying to create an image with the same data URI as an already existing image will also result in an error.
     * @param {string} dataset
     * @param {string} dataUri
     * @param {Blob} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesControllerCreateForm(
      dataset: string,
      dataUri: string,
      file: Blob,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Image>> {
      return ImagesApiFp(configuration)
        .imagesControllerCreateForm(dataset, dataUri, file, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves a list of all available images. If there do not exist any images it will return an empty array. If a dataset or job is specified, it will return all images in the dataset or used by the job. If the dataset or job does not exist it will return an empty array.
     * @param {string} [dataset] The dataset identifier (uuid) to filter the images by.
     * @param {string} [job] The job identifier (uuid) to filter the images by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesControllerFindAll(
      dataset?: string,
      job?: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Array<Image>>> {
      return ImagesApiFp(configuration)
        .imagesControllerFindAll(dataset, job, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves an image, if a valid identifier was provided. Otherwise it returns an error.
     * @param {string} id The identifier (uuid) of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesControllerFindOne(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Image>> {
      return ImagesApiFp(configuration)
        .imagesControllerFindOne(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns the file for an image.
     * @param {string} id The identifier (uuid) of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesControllerGetFile(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Blob>> {
      return ImagesApiFp(configuration)
        .imagesControllerGetFile(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes an image and associated annotations permanently. It cannot be undone. It returns an error if the image can not be found or the delete operation fails.
     * @param {string} id The identifier (uuid) of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesControllerRemove(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      return ImagesApiFp(configuration)
        .imagesControllerRemove(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes all selected images and all associated annotations permanently. It cannot be undone. It returns the images that were deleted.
     * @param {DeleteAllDto} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesControllerRemoveAll(
      body: DeleteAllDto,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      return ImagesApiFp(configuration)
        .imagesControllerRemoveAll(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates the specified image by setting the values of the parameters passed. Additionally it saves the optional file passed to this endpoint under the image's (new) dataUri. It returns the updated image, if the update operation succeeds. It returns an error when trying to set the image data URI to an already existing image data URI. When changing the dataUri, the old file won't be deleted automatically.
     * @param {string} dataUri
     * @param {Blob} file
     * @param {string} id The identifier (uuid) of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesControllerUpdateForm(
      dataUri: string,
      file: Blob,
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Image>> {
      return ImagesApiFp(configuration)
        .imagesControllerUpdateForm(dataUri, file, id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ImagesApi - object-oriented interface
 * @export
 * @class ImagesApi
 * @extends {BaseAPI}
 */
export class ImagesApi extends BaseAPI {
  /**
   * Creates a new image and returns it. Additionally it saves the optional file passed to this endpoint under the image's dataUri. An error will be thrown if the referenced dataset does not exist. Trying to create an image with the same data URI as an already existing image will also result in an error.
   * @param {string} dataset
   * @param {string} dataUri
   * @param {Blob} file
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImagesApi
   */
  public async imagesControllerCreateForm(
    dataset: string,
    dataUri: string,
    file: Blob,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Image>> {
    return ImagesApiFp(this.configuration)
      .imagesControllerCreateForm(dataset, dataUri, file, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves a list of all available images. If there do not exist any images it will return an empty array. If a dataset or job is specified, it will return all images in the dataset or used by the job. If the dataset or job does not exist it will return an empty array.
   * @param {string} [dataset] The dataset identifier (uuid) to filter the images by.
   * @param {string} [job] The job identifier (uuid) to filter the images by.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImagesApi
   */
  public async imagesControllerFindAll(
    dataset?: string,
    job?: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Array<Image>>> {
    return ImagesApiFp(this.configuration)
      .imagesControllerFindAll(dataset, job, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves an image, if a valid identifier was provided. Otherwise it returns an error.
   * @param {string} id The identifier (uuid) of the image.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImagesApi
   */
  public async imagesControllerFindOne(
    id: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Image>> {
    return ImagesApiFp(this.configuration)
      .imagesControllerFindOne(id, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Returns the file for an image.
   * @param {string} id The identifier (uuid) of the image.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImagesApi
   */
  public async imagesControllerGetFile(
    id: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Blob>> {
    return ImagesApiFp(this.configuration)
      .imagesControllerGetFile(id, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes an image and associated annotations permanently. It cannot be undone. It returns an error if the image can not be found or the delete operation fails.
   * @param {string} id The identifier (uuid) of the image.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImagesApi
   */
  public async imagesControllerRemove(
    id: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<void>> {
    return ImagesApiFp(this.configuration)
      .imagesControllerRemove(id, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes all selected images and all associated annotations permanently. It cannot be undone. It returns the images that were deleted.
   * @param {DeleteAllDto} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImagesApi
   */
  public async imagesControllerRemoveAll(
    body: DeleteAllDto,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<void>> {
    return ImagesApiFp(this.configuration)
      .imagesControllerRemoveAll(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Updates the specified image by setting the values of the parameters passed. Additionally it saves the optional file passed to this endpoint under the image's (new) dataUri. It returns the updated image, if the update operation succeeds. It returns an error when trying to set the image data URI to an already existing image data URI. When changing the dataUri, the old file won't be deleted automatically.
   * @param {string} dataUri
   * @param {Blob} file
   * @param {string} id The identifier (uuid) of the image.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImagesApi
   */
  public async imagesControllerUpdateForm(
    dataUri: string,
    file: Blob,
    id: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Image>> {
    return ImagesApiFp(this.configuration)
      .imagesControllerUpdateForm(dataUri, file, id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
