/* tslint:disable */
/* eslint-disable */
/**
 * Annotation Service
 * A service to make medical image annotation as enjoyable as possible.
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Annotation
 */
export interface Annotation {
    /**
     * The identifier (uuid) of the annotation.
     * @type {string}
     * @memberof Annotation
     */
    'id': string;
    /**
     * The path of the annotation file relative to the specified data source location.
     * @type {string}
     * @memberof Annotation
     */
    'dataUri': string;
    /**
     * Indicates whether an annotation has been verified by a human.
     * @type {boolean}
     * @memberof Annotation
     */
    'verified': boolean;
    /**
     * The identifier of the image (uuid) that the annotation belongs to.
     * @type {string}
     * @memberof Annotation
     */
    'image': string;
    /**
     * 
     * @type {Job}
     * @memberof Annotation
     */
    'job': Job;
    /**
     * The date and time the annotation was created.
     * @type {string}
     * @memberof Annotation
     */
    'createdAt': string;
    /**
     * The date and time the annotation was last updated.
     * @type {string}
     * @memberof Annotation
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface CreateDatasetDto
 */
export interface CreateDatasetDto {
    /**
     * The name of the dataset.
     * @type {string}
     * @memberof CreateDatasetDto
     */
    'name': string;
    /**
     * The identifier of the project (uuid) that the dataset will belong to.
     * @type {string}
     * @memberof CreateDatasetDto
     */
    'project': string;
}
/**
 * 
 * @export
 * @interface CreateJobDto
 */
export interface CreateJobDto {
    /**
     * The name of the model that will be used to annotate images.
     * @type {string}
     * @memberof CreateJobDto
     */
    'modelName': string;
    /**
     * The version of the model that will be used to annotate images.
     * @type {string}
     * @memberof CreateJobDto
     */
    'modelVersion': string;
    /**
     * The identifier of the project (uuid) that the job will belong to.
     * @type {string}
     * @memberof CreateJobDto
     */
    'project': string;
    /**
     * A list of the images that should be annotated. Each image is represented by its identifier (uuid).
     * @type {Array<string>}
     * @memberof CreateJobDto
     */
    'images': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateProjectDto
 */
export interface CreateProjectDto {
    /**
     * The name of the project.
     * @type {string}
     * @memberof CreateProjectDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Dataset
 */
export interface Dataset {
    /**
     * The identifier (uuid) of the dataset.
     * @type {string}
     * @memberof Dataset
     */
    'id': string;
    /**
     * The name of the dataset.
     * @type {string}
     * @memberof Dataset
     */
    'name': string;
    /**
     * The identifier of the project (uuid) that the dataset belongs to.
     * @type {string}
     * @memberof Dataset
     */
    'project': string;
    /**
     * The date and time the project was created.
     * @type {string}
     * @memberof Dataset
     */
    'createdAt': string;
    /**
     * The date and time the project was last updated.
     * @type {string}
     * @memberof Dataset
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface DeleteAllDto
 */
export interface DeleteAllDto {
    /**
     * The UUIDs of the objects to be deleted.
     * @type {Array<string>}
     * @memberof DeleteAllDto
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * The identifier (uuid) of the image.
     * @type {string}
     * @memberof Image
     */
    'id': string;
    /**
     * The path of the image file relative to the specified data source location.
     * @type {string}
     * @memberof Image
     */
    'dataUri': string;
    /**
     * The identifier of the dataset (uuid) that the image belongs to.
     * @type {string}
     * @memberof Image
     */
    'dataset': string;
    /**
     * The date and time the image was created.
     * @type {string}
     * @memberof Image
     */
    'createdAt': string;
    /**
     * The date and time the image was last updated.
     * @type {string}
     * @memberof Image
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface Job
 */
export interface Job {
    /**
     * The identifier (uuid) of the job.
     * @type {string}
     * @memberof Job
     */
    'id': string;
    /**
     * The name of the project to which the job belongs.
     * @type {string}
     * @memberof Job
     */
    'project': string;
    /**
     * The name of the model used to annotate the images.
     * @type {string}
     * @memberof Job
     */
    'modelName': string;
    /**
     * The version of the model used to annotate the images.
     * @type {string}
     * @memberof Job
     */
    'modelVersion': string;
    /**
     * The current status of the job. By default it is `queued`, which means that the job is waiting to be processed. When the job is being processed, its status is `running`. When the job is finished, its status is `succeeded` or `failed`. The user can also cancel the job, which will change its status to `canceled`.
     * @type {string}
     * @memberof Job
     */
    'status': JobStatusEnum;
    /**
     * The path of the log file of the job.
     * @type {string}
     * @memberof Job
     */
    'logFileUri': string;
    /**
     * The date and time at which the processing of the job was started, i.e. the annotation process started. This date will be `null` if the job has not been started.
     * @type {string}
     * @memberof Job
     */
    'startedAt': string;
    /**
     * The date and time at which the processing of the job was ended, i.e. the annotation process ended. This date will be `null` if the job has not yet finished.
     * @type {string}
     * @memberof Job
     */
    'finishedAt': string;
    /**
     * The date and time the job was created.
     * @type {string}
     * @memberof Job
     */
    'createdAt': string;
    /**
     * The date and time the job was last updated.
     * @type {string}
     * @memberof Job
     */
    'updatedAt': string;
}

export const JobStatusEnum = {
    Queued: 'queued',
    Running: 'running',
    Succeeded: 'succeeded',
    Failed: 'failed',
    Canceled: 'canceled'
} as const;

export type JobStatusEnum = typeof JobStatusEnum[keyof typeof JobStatusEnum];

/**
 * 
 * @export
 * @interface ModelVersion
 */
export interface ModelVersion {
    /**
     * The name of the model.
     * @type {string}
     * @memberof ModelVersion
     */
    'name': string;
    /**
     * The version of the model.
     * @type {string}
     * @memberof ModelVersion
     */
    'version': string;
    /**
     * The description of the model.
     * @type {string}
     * @memberof ModelVersion
     */
    'description': string;
    /**
     * The list of model version tags.
     * @type {Array<ModelVersionTag>}
     * @memberof ModelVersion
     */
    'tags': Array<ModelVersionTag>;
    /**
     * The date and time the model version was created.
     * @type {string}
     * @memberof ModelVersion
     */
    'createdAt': string;
    /**
     * The date and time the model version was last updated.
     * @type {string}
     * @memberof ModelVersion
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface ModelVersionTag
 */
export interface ModelVersionTag {
    /**
     * The name of the key.
     * @type {string}
     * @memberof ModelVersionTag
     */
    'key': string;
    /**
     * The name of the value.
     * @type {string}
     * @memberof ModelVersionTag
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface Progress
 */
export interface Progress {
    /**
     * The total number of images in progress of being annotated.
     * @type {number}
     * @memberof Progress
     */
    'totalImages': number;
    /**
     * The number of annotated images.
     * @type {number}
     * @memberof Progress
     */
    'annotatedImages': number;
    /**
     * The number of annotated images that have at least one verified annotation.
     * @type {number}
     * @memberof Progress
     */
    'verifiedImages': number;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * The identifier (uuid) of the project.
     * @type {string}
     * @memberof Project
     */
    'id': string;
    /**
     * The name of the project.
     * @type {string}
     * @memberof Project
     */
    'name': string;
    /**
     * The date and time the project was created.
     * @type {string}
     * @memberof Project
     */
    'createdAt': string;
    /**
     * The date and time the project was last updated.
     * @type {string}
     * @memberof Project
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface UpdateDatasetDto
 */
export interface UpdateDatasetDto {
    /**
     * The name of the dataset.
     * @type {string}
     * @memberof UpdateDatasetDto
     */
    'name': string;
    /**
     * The identifier of the project (uuid) that the dataset will belong to.
     * @type {string}
     * @memberof UpdateDatasetDto
     */
    'project': string;
}
/**
 * 
 * @export
 * @interface UpdateProjectDto
 */
export interface UpdateProjectDto {
    /**
     * The name of the project.
     * @type {string}
     * @memberof UpdateProjectDto
     */
    'name': string;
}

/**
 * AnnotationsApi - axios parameter creator
 * @export
 */
export const AnnotationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new annotation and returns it. Additionally it saves the optional file passed to this endpoint under the annotation\'s dataUri. An error will be thrown if the referenced image does not exist. Trying to create an annotation with the same data URI as an already existing annotation will also result in an error.
         * @summary 
         * @param {string} image The identifier of the image (uuid) that the annotation will belong to.
         * @param {string} dataUri The path of the annotation file relative to the specified data source location.
         * @param {string} [job] The identifier of the job (uuid) that the annotation was created by.
         * @param {boolean} [verified] Indicates whether an annotation has been verified by a human. Set to false by default.
         * @param {File} [file] The annotation file. Should be passed if the file is not already present in the data source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsControllerCreate: async (image: string, dataUri: string, job?: string, verified?: boolean, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'image' is not null or undefined
            assertParamExists('annotationsControllerCreate', 'image', image)
            // verify required parameter 'dataUri' is not null or undefined
            assertParamExists('annotationsControllerCreate', 'dataUri', dataUri)
            const localVarPath = `/annotations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (job !== undefined) { 
                localVarFormParams.append('job', job as any);
            }
    
            if (dataUri !== undefined) { 
                localVarFormParams.append('dataUri', dataUri as any);
            }
    
            if (verified !== undefined) { 
                localVarFormParams.append('verified', verified as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all available annotations. If there do not exist any annotations it will return an empty array. If an image or job is specified, it will return all annotations belonging to the image (if specified) and generated by the job (if specified). If the image or job does not exist it will return an empty array.
         * @summary 
         * @param {string} [image] The image identifier (uuid) to filter the annotations by.
         * @param {string} [job] The job identifier (uuid) to filter the annotations by.
         * @param {any} [verified] If set to true, only human-verified annotations are returned. When set to false, non-verified annotations are returned. If no value is provided, all annotations are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsControllerFindAll: async (image?: string, job?: string, verified?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/annotations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (image !== undefined) {
                localVarQueryParameter['image'] = image;
            }

            if (job !== undefined) {
                localVarQueryParameter['job'] = job;
            }

            if (verified !== undefined) {
                localVarQueryParameter['verified'] = verified;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves an annotation, if a valid identifier was provided. Otherwise it returns an error.
         * @summary 
         * @param {string} id The identifier (uuid) of the annotation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('annotationsControllerFindOne', 'id', id)
            const localVarPath = `/annotations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the file for an annotation.
         * @summary 
         * @param {string} id The identifier (uuid) of the annotation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsControllerGetFile: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('annotationsControllerGetFile', 'id', id)
            const localVarPath = `/annotations/{id}/file`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an annotation permanently. It cannot be undone. It does not delete associated images or jobs. It returns an error if the annotation can not be found or the delete operation fails.
         * @summary 
         * @param {string} id The identifier (uuid) of the annotation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsControllerRemove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('annotationsControllerRemove', 'id', id)
            const localVarPath = `/annotations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all selected annotations permanently. It cannot be undone. It returns the annotations that were deleted.
         * @summary 
         * @param {DeleteAllDto} deleteAllDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsControllerRemoveAll: async (deleteAllDto: DeleteAllDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteAllDto' is not null or undefined
            assertParamExists('annotationsControllerRemoveAll', 'deleteAllDto', deleteAllDto)
            const localVarPath = `/annotations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteAllDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the specified annotation by setting the values of the parameters passed. Additionally it saves the optional file passed to this endpoint under the annotation\'s (new) dataUri. All parameters not provided will be left unchanged. It returns the updated annotation, if the update operation succeeds. Otherwise it returns an error. When changing the dataUri, the old file won\'t be deleted automatically.
         * @summary 
         * @param {string} id The identifier (uuid) of the annotation.
         * @param {string} [dataUri] The path of the annotation file relative to the specified data source location.
         * @param {boolean} [verified] Indicates whether an annotation has been verified by a human. Set to false by default.
         * @param {File} [file] The annotation file. Should be passed to update the file referenced by the dataUri.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsControllerUpdate: async (id: string, dataUri?: string, verified?: boolean, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('annotationsControllerUpdate', 'id', id)
            const localVarPath = `/annotations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (dataUri !== undefined) { 
                localVarFormParams.append('dataUri', dataUri as any);
            }
    
            if (verified !== undefined) { 
                localVarFormParams.append('verified', verified as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnnotationsApi - functional programming interface
 * @export
 */
export const AnnotationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnnotationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new annotation and returns it. Additionally it saves the optional file passed to this endpoint under the annotation\'s dataUri. An error will be thrown if the referenced image does not exist. Trying to create an annotation with the same data URI as an already existing annotation will also result in an error.
         * @summary 
         * @param {string} image The identifier of the image (uuid) that the annotation will belong to.
         * @param {string} dataUri The path of the annotation file relative to the specified data source location.
         * @param {string} [job] The identifier of the job (uuid) that the annotation was created by.
         * @param {boolean} [verified] Indicates whether an annotation has been verified by a human. Set to false by default.
         * @param {File} [file] The annotation file. Should be passed if the file is not already present in the data source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsControllerCreate(image: string, dataUri: string, job?: string, verified?: boolean, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Annotation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsControllerCreate(image, dataUri, job, verified, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of all available annotations. If there do not exist any annotations it will return an empty array. If an image or job is specified, it will return all annotations belonging to the image (if specified) and generated by the job (if specified). If the image or job does not exist it will return an empty array.
         * @summary 
         * @param {string} [image] The image identifier (uuid) to filter the annotations by.
         * @param {string} [job] The job identifier (uuid) to filter the annotations by.
         * @param {any} [verified] If set to true, only human-verified annotations are returned. When set to false, non-verified annotations are returned. If no value is provided, all annotations are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsControllerFindAll(image?: string, job?: string, verified?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Annotation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsControllerFindAll(image, job, verified, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves an annotation, if a valid identifier was provided. Otherwise it returns an error.
         * @summary 
         * @param {string} id The identifier (uuid) of the annotation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Annotation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the file for an annotation.
         * @summary 
         * @param {string} id The identifier (uuid) of the annotation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsControllerGetFile(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsControllerGetFile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes an annotation permanently. It cannot be undone. It does not delete associated images or jobs. It returns an error if the annotation can not be found or the delete operation fails.
         * @summary 
         * @param {string} id The identifier (uuid) of the annotation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsControllerRemove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsControllerRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes all selected annotations permanently. It cannot be undone. It returns the annotations that were deleted.
         * @summary 
         * @param {DeleteAllDto} deleteAllDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsControllerRemoveAll(deleteAllDto: DeleteAllDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsControllerRemoveAll(deleteAllDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the specified annotation by setting the values of the parameters passed. Additionally it saves the optional file passed to this endpoint under the annotation\'s (new) dataUri. All parameters not provided will be left unchanged. It returns the updated annotation, if the update operation succeeds. Otherwise it returns an error. When changing the dataUri, the old file won\'t be deleted automatically.
         * @summary 
         * @param {string} id The identifier (uuid) of the annotation.
         * @param {string} [dataUri] The path of the annotation file relative to the specified data source location.
         * @param {boolean} [verified] Indicates whether an annotation has been verified by a human. Set to false by default.
         * @param {File} [file] The annotation file. Should be passed to update the file referenced by the dataUri.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsControllerUpdate(id: string, dataUri?: string, verified?: boolean, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Annotation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsControllerUpdate(id, dataUri, verified, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AnnotationsApi - factory interface
 * @export
 */
export const AnnotationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnnotationsApiFp(configuration)
    return {
        /**
         * Creates a new annotation and returns it. Additionally it saves the optional file passed to this endpoint under the annotation\'s dataUri. An error will be thrown if the referenced image does not exist. Trying to create an annotation with the same data URI as an already existing annotation will also result in an error.
         * @summary 
         * @param {string} image The identifier of the image (uuid) that the annotation will belong to.
         * @param {string} dataUri The path of the annotation file relative to the specified data source location.
         * @param {string} [job] The identifier of the job (uuid) that the annotation was created by.
         * @param {boolean} [verified] Indicates whether an annotation has been verified by a human. Set to false by default.
         * @param {File} [file] The annotation file. Should be passed if the file is not already present in the data source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsControllerCreate(image: string, dataUri: string, job?: string, verified?: boolean, file?: File, options?: any): AxiosPromise<Annotation> {
            return localVarFp.annotationsControllerCreate(image, dataUri, job, verified, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all available annotations. If there do not exist any annotations it will return an empty array. If an image or job is specified, it will return all annotations belonging to the image (if specified) and generated by the job (if specified). If the image or job does not exist it will return an empty array.
         * @summary 
         * @param {string} [image] The image identifier (uuid) to filter the annotations by.
         * @param {string} [job] The job identifier (uuid) to filter the annotations by.
         * @param {any} [verified] If set to true, only human-verified annotations are returned. When set to false, non-verified annotations are returned. If no value is provided, all annotations are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsControllerFindAll(image?: string, job?: string, verified?: any, options?: any): AxiosPromise<Array<Annotation>> {
            return localVarFp.annotationsControllerFindAll(image, job, verified, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves an annotation, if a valid identifier was provided. Otherwise it returns an error.
         * @summary 
         * @param {string} id The identifier (uuid) of the annotation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsControllerFindOne(id: string, options?: any): AxiosPromise<Annotation> {
            return localVarFp.annotationsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the file for an annotation.
         * @summary 
         * @param {string} id The identifier (uuid) of the annotation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsControllerGetFile(id: string, options?: any): AxiosPromise<File> {
            return localVarFp.annotationsControllerGetFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an annotation permanently. It cannot be undone. It does not delete associated images or jobs. It returns an error if the annotation can not be found or the delete operation fails.
         * @summary 
         * @param {string} id The identifier (uuid) of the annotation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.annotationsControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes all selected annotations permanently. It cannot be undone. It returns the annotations that were deleted.
         * @summary 
         * @param {DeleteAllDto} deleteAllDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsControllerRemoveAll(deleteAllDto: DeleteAllDto, options?: any): AxiosPromise<void> {
            return localVarFp.annotationsControllerRemoveAll(deleteAllDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the specified annotation by setting the values of the parameters passed. Additionally it saves the optional file passed to this endpoint under the annotation\'s (new) dataUri. All parameters not provided will be left unchanged. It returns the updated annotation, if the update operation succeeds. Otherwise it returns an error. When changing the dataUri, the old file won\'t be deleted automatically.
         * @summary 
         * @param {string} id The identifier (uuid) of the annotation.
         * @param {string} [dataUri] The path of the annotation file relative to the specified data source location.
         * @param {boolean} [verified] Indicates whether an annotation has been verified by a human. Set to false by default.
         * @param {File} [file] The annotation file. Should be passed to update the file referenced by the dataUri.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsControllerUpdate(id: string, dataUri?: string, verified?: boolean, file?: File, options?: any): AxiosPromise<Annotation> {
            return localVarFp.annotationsControllerUpdate(id, dataUri, verified, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnnotationsApi - object-oriented interface
 * @export
 * @class AnnotationsApi
 * @extends {BaseAPI}
 */
export class AnnotationsApi extends BaseAPI {
    /**
     * Creates a new annotation and returns it. Additionally it saves the optional file passed to this endpoint under the annotation\'s dataUri. An error will be thrown if the referenced image does not exist. Trying to create an annotation with the same data URI as an already existing annotation will also result in an error.
     * @summary 
     * @param {string} image The identifier of the image (uuid) that the annotation will belong to.
     * @param {string} dataUri The path of the annotation file relative to the specified data source location.
     * @param {string} [job] The identifier of the job (uuid) that the annotation was created by.
     * @param {boolean} [verified] Indicates whether an annotation has been verified by a human. Set to false by default.
     * @param {File} [file] The annotation file. Should be passed if the file is not already present in the data source.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public annotationsControllerCreate(image: string, dataUri: string, job?: string, verified?: boolean, file?: File, options?: AxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).annotationsControllerCreate(image, dataUri, job, verified, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all available annotations. If there do not exist any annotations it will return an empty array. If an image or job is specified, it will return all annotations belonging to the image (if specified) and generated by the job (if specified). If the image or job does not exist it will return an empty array.
     * @summary 
     * @param {string} [image] The image identifier (uuid) to filter the annotations by.
     * @param {string} [job] The job identifier (uuid) to filter the annotations by.
     * @param {any} [verified] If set to true, only human-verified annotations are returned. When set to false, non-verified annotations are returned. If no value is provided, all annotations are returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public annotationsControllerFindAll(image?: string, job?: string, verified?: any, options?: AxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).annotationsControllerFindAll(image, job, verified, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves an annotation, if a valid identifier was provided. Otherwise it returns an error.
     * @summary 
     * @param {string} id The identifier (uuid) of the annotation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public annotationsControllerFindOne(id: string, options?: AxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).annotationsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the file for an annotation.
     * @summary 
     * @param {string} id The identifier (uuid) of the annotation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public annotationsControllerGetFile(id: string, options?: AxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).annotationsControllerGetFile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an annotation permanently. It cannot be undone. It does not delete associated images or jobs. It returns an error if the annotation can not be found or the delete operation fails.
     * @summary 
     * @param {string} id The identifier (uuid) of the annotation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public annotationsControllerRemove(id: string, options?: AxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).annotationsControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes all selected annotations permanently. It cannot be undone. It returns the annotations that were deleted.
     * @summary 
     * @param {DeleteAllDto} deleteAllDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public annotationsControllerRemoveAll(deleteAllDto: DeleteAllDto, options?: AxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).annotationsControllerRemoveAll(deleteAllDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the specified annotation by setting the values of the parameters passed. Additionally it saves the optional file passed to this endpoint under the annotation\'s (new) dataUri. All parameters not provided will be left unchanged. It returns the updated annotation, if the update operation succeeds. Otherwise it returns an error. When changing the dataUri, the old file won\'t be deleted automatically.
     * @summary 
     * @param {string} id The identifier (uuid) of the annotation.
     * @param {string} [dataUri] The path of the annotation file relative to the specified data source location.
     * @param {boolean} [verified] Indicates whether an annotation has been verified by a human. Set to false by default.
     * @param {File} [file] The annotation file. Should be passed to update the file referenced by the dataUri.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public annotationsControllerUpdate(id: string, dataUri?: string, verified?: boolean, file?: File, options?: AxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).annotationsControllerUpdate(id, dataUri, verified, file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DatasetsApi - axios parameter creator
 * @export
 */
export const DatasetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new dataset and returns it. An error will be thrown if the referenced project does not exist.
         * @summary 
         * @param {CreateDatasetDto} createDatasetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsControllerCreate: async (createDatasetDto: CreateDatasetDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDatasetDto' is not null or undefined
            assertParamExists('datasetsControllerCreate', 'createDatasetDto', createDatasetDto)
            const localVarPath = `/datasets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDatasetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all available datasets. If there do not exist any datasets it will return an empty array. If a project is specified, it will return all datasets in the project. If the project does not exist, it will return an empty array as well.
         * @summary 
         * @param {string} [project] The project identifier (uuid) to filter the datasets by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsControllerFindAll: async (project?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/datasets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (project !== undefined) {
                localVarQueryParameter['project'] = project;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a dataset, if a valid identifier was provided. Otherwise it returns an error.
         * @summary 
         * @param {string} id The identifier (uuid) of the dataset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('datasetsControllerFindOne', 'id', id)
            const localVarPath = `/datasets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the annotation progress of a dataset. If the dataset does not exist, it will return an error.
         * @summary 
         * @param {string} id The identifier (uuid) of the dataset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsControllerProgress: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('datasetsControllerProgress', 'id', id)
            const localVarPath = `/datasets/{id}/progress`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a dataset and associated images and their annotations permanently. It cannot be undone. It returns an error if the dataset can not be found or the delete operation fails.
         * @summary 
         * @param {string} id The identifier (uuid) of the dataset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsControllerRemove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('datasetsControllerRemove', 'id', id)
            const localVarPath = `/datasets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all selected datasets and associated images and their annotations permanently. It cannot be undone. It returns the datasets that were deleted.
         * @summary 
         * @param {DeleteAllDto} deleteAllDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsControllerRemoveAll: async (deleteAllDto: DeleteAllDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteAllDto' is not null or undefined
            assertParamExists('datasetsControllerRemoveAll', 'deleteAllDto', deleteAllDto)
            const localVarPath = `/datasets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteAllDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the specified dataset by setting the values of the parameters passed. It returns the updated dataset, if the update operation succeeds. An error will be thrown if the referenced project does not exist.
         * @summary 
         * @param {string} id The identifier (uuid) of the dataset.
         * @param {UpdateDatasetDto} updateDatasetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsControllerUpdate: async (id: string, updateDatasetDto: UpdateDatasetDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('datasetsControllerUpdate', 'id', id)
            // verify required parameter 'updateDatasetDto' is not null or undefined
            assertParamExists('datasetsControllerUpdate', 'updateDatasetDto', updateDatasetDto)
            const localVarPath = `/datasets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDatasetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatasetsApi - functional programming interface
 * @export
 */
export const DatasetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatasetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new dataset and returns it. An error will be thrown if the referenced project does not exist.
         * @summary 
         * @param {CreateDatasetDto} createDatasetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datasetsControllerCreate(createDatasetDto: CreateDatasetDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.datasetsControllerCreate(createDatasetDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of all available datasets. If there do not exist any datasets it will return an empty array. If a project is specified, it will return all datasets in the project. If the project does not exist, it will return an empty array as well.
         * @summary 
         * @param {string} [project] The project identifier (uuid) to filter the datasets by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datasetsControllerFindAll(project?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dataset>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.datasetsControllerFindAll(project, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a dataset, if a valid identifier was provided. Otherwise it returns an error.
         * @summary 
         * @param {string} id The identifier (uuid) of the dataset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datasetsControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.datasetsControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the annotation progress of a dataset. If the dataset does not exist, it will return an error.
         * @summary 
         * @param {string} id The identifier (uuid) of the dataset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datasetsControllerProgress(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Progress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.datasetsControllerProgress(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a dataset and associated images and their annotations permanently. It cannot be undone. It returns an error if the dataset can not be found or the delete operation fails.
         * @summary 
         * @param {string} id The identifier (uuid) of the dataset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datasetsControllerRemove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.datasetsControllerRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes all selected datasets and associated images and their annotations permanently. It cannot be undone. It returns the datasets that were deleted.
         * @summary 
         * @param {DeleteAllDto} deleteAllDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datasetsControllerRemoveAll(deleteAllDto: DeleteAllDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.datasetsControllerRemoveAll(deleteAllDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the specified dataset by setting the values of the parameters passed. It returns the updated dataset, if the update operation succeeds. An error will be thrown if the referenced project does not exist.
         * @summary 
         * @param {string} id The identifier (uuid) of the dataset.
         * @param {UpdateDatasetDto} updateDatasetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datasetsControllerUpdate(id: string, updateDatasetDto: UpdateDatasetDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.datasetsControllerUpdate(id, updateDatasetDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatasetsApi - factory interface
 * @export
 */
export const DatasetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatasetsApiFp(configuration)
    return {
        /**
         * Creates a new dataset and returns it. An error will be thrown if the referenced project does not exist.
         * @summary 
         * @param {CreateDatasetDto} createDatasetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsControllerCreate(createDatasetDto: CreateDatasetDto, options?: any): AxiosPromise<Dataset> {
            return localVarFp.datasetsControllerCreate(createDatasetDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all available datasets. If there do not exist any datasets it will return an empty array. If a project is specified, it will return all datasets in the project. If the project does not exist, it will return an empty array as well.
         * @summary 
         * @param {string} [project] The project identifier (uuid) to filter the datasets by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsControllerFindAll(project?: string, options?: any): AxiosPromise<Array<Dataset>> {
            return localVarFp.datasetsControllerFindAll(project, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a dataset, if a valid identifier was provided. Otherwise it returns an error.
         * @summary 
         * @param {string} id The identifier (uuid) of the dataset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsControllerFindOne(id: string, options?: any): AxiosPromise<Dataset> {
            return localVarFp.datasetsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the annotation progress of a dataset. If the dataset does not exist, it will return an error.
         * @summary 
         * @param {string} id The identifier (uuid) of the dataset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsControllerProgress(id: string, options?: any): AxiosPromise<Progress> {
            return localVarFp.datasetsControllerProgress(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a dataset and associated images and their annotations permanently. It cannot be undone. It returns an error if the dataset can not be found or the delete operation fails.
         * @summary 
         * @param {string} id The identifier (uuid) of the dataset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.datasetsControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes all selected datasets and associated images and their annotations permanently. It cannot be undone. It returns the datasets that were deleted.
         * @summary 
         * @param {DeleteAllDto} deleteAllDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsControllerRemoveAll(deleteAllDto: DeleteAllDto, options?: any): AxiosPromise<void> {
            return localVarFp.datasetsControllerRemoveAll(deleteAllDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the specified dataset by setting the values of the parameters passed. It returns the updated dataset, if the update operation succeeds. An error will be thrown if the referenced project does not exist.
         * @summary 
         * @param {string} id The identifier (uuid) of the dataset.
         * @param {UpdateDatasetDto} updateDatasetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsControllerUpdate(id: string, updateDatasetDto: UpdateDatasetDto, options?: any): AxiosPromise<Dataset> {
            return localVarFp.datasetsControllerUpdate(id, updateDatasetDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatasetsApi - object-oriented interface
 * @export
 * @class DatasetsApi
 * @extends {BaseAPI}
 */
export class DatasetsApi extends BaseAPI {
    /**
     * Creates a new dataset and returns it. An error will be thrown if the referenced project does not exist.
     * @summary 
     * @param {CreateDatasetDto} createDatasetDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public datasetsControllerCreate(createDatasetDto: CreateDatasetDto, options?: AxiosRequestConfig) {
        return DatasetsApiFp(this.configuration).datasetsControllerCreate(createDatasetDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all available datasets. If there do not exist any datasets it will return an empty array. If a project is specified, it will return all datasets in the project. If the project does not exist, it will return an empty array as well.
     * @summary 
     * @param {string} [project] The project identifier (uuid) to filter the datasets by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public datasetsControllerFindAll(project?: string, options?: AxiosRequestConfig) {
        return DatasetsApiFp(this.configuration).datasetsControllerFindAll(project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a dataset, if a valid identifier was provided. Otherwise it returns an error.
     * @summary 
     * @param {string} id The identifier (uuid) of the dataset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public datasetsControllerFindOne(id: string, options?: AxiosRequestConfig) {
        return DatasetsApiFp(this.configuration).datasetsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the annotation progress of a dataset. If the dataset does not exist, it will return an error.
     * @summary 
     * @param {string} id The identifier (uuid) of the dataset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public datasetsControllerProgress(id: string, options?: AxiosRequestConfig) {
        return DatasetsApiFp(this.configuration).datasetsControllerProgress(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a dataset and associated images and their annotations permanently. It cannot be undone. It returns an error if the dataset can not be found or the delete operation fails.
     * @summary 
     * @param {string} id The identifier (uuid) of the dataset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public datasetsControllerRemove(id: string, options?: AxiosRequestConfig) {
        return DatasetsApiFp(this.configuration).datasetsControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes all selected datasets and associated images and their annotations permanently. It cannot be undone. It returns the datasets that were deleted.
     * @summary 
     * @param {DeleteAllDto} deleteAllDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public datasetsControllerRemoveAll(deleteAllDto: DeleteAllDto, options?: AxiosRequestConfig) {
        return DatasetsApiFp(this.configuration).datasetsControllerRemoveAll(deleteAllDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the specified dataset by setting the values of the parameters passed. It returns the updated dataset, if the update operation succeeds. An error will be thrown if the referenced project does not exist.
     * @summary 
     * @param {string} id The identifier (uuid) of the dataset.
     * @param {UpdateDatasetDto} updateDatasetDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public datasetsControllerUpdate(id: string, updateDatasetDto: UpdateDatasetDto, options?: AxiosRequestConfig) {
        return DatasetsApiFp(this.configuration).datasetsControllerUpdate(id, updateDatasetDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImagesApi - axios parameter creator
 * @export
 */
export const ImagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new image and returns it. Additionally it saves the optional file passed to this endpoint under the image\'s dataUri. An error will be thrown if the referenced dataset does not exist. Trying to create an image with the same data URI as an already existing image will also result in an error.
         * @summary 
         * @param {string} dataset The identifier of the dataset (uuid) that the image will belong to.
         * @param {string} dataUri The path of the image file relative to the specified data source location.
         * @param {File} file The image file. Should be passed if the file is not already present in the data source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerCreate: async (dataset: string, dataUri: string, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataset' is not null or undefined
            assertParamExists('imagesControllerCreate', 'dataset', dataset)
            // verify required parameter 'dataUri' is not null or undefined
            assertParamExists('imagesControllerCreate', 'dataUri', dataUri)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('imagesControllerCreate', 'file', file)
            const localVarPath = `/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (dataset !== undefined) { 
                localVarFormParams.append('dataset', dataset as any);
            }
    
            if (dataUri !== undefined) { 
                localVarFormParams.append('dataUri', dataUri as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all available images. If there do not exist any images it will return an empty array. If a dataset or job is specified, it will return all images in the dataset or used by the job. If the dataset or job does not exist it will return an empty array.
         * @summary 
         * @param {string} [dataset] The dataset identifier (uuid) to filter the images by.
         * @param {string} [job] The job identifier (uuid) to filter the images by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerFindAll: async (dataset?: string, job?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dataset !== undefined) {
                localVarQueryParameter['dataset'] = dataset;
            }

            if (job !== undefined) {
                localVarQueryParameter['job'] = job;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves an image, if a valid identifier was provided. Otherwise it returns an error.
         * @summary 
         * @param {string} id The identifier (uuid) of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagesControllerFindOne', 'id', id)
            const localVarPath = `/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the file for an image.
         * @summary 
         * @param {string} id The identifier (uuid) of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerGetFile: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagesControllerGetFile', 'id', id)
            const localVarPath = `/images/{id}/file`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an image and associated annotations permanently. It cannot be undone. It returns an error if the image can not be found or the delete operation fails.
         * @summary 
         * @param {string} id The identifier (uuid) of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerRemove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagesControllerRemove', 'id', id)
            const localVarPath = `/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all selected images and all associated annotations permanently. It cannot be undone. It returns the images that were deleted.
         * @summary 
         * @param {DeleteAllDto} deleteAllDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerRemoveAll: async (deleteAllDto: DeleteAllDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteAllDto' is not null or undefined
            assertParamExists('imagesControllerRemoveAll', 'deleteAllDto', deleteAllDto)
            const localVarPath = `/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteAllDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the specified image by setting the values of the parameters passed. Additionally it saves the optional file passed to this endpoint under the image\'s (new) dataUri. It returns the updated image, if the update operation succeeds. It returns an error when trying to set the image data URI to an already existing image data URI. When changing the dataUri, the old file won\'t be deleted automatically.
         * @summary 
         * @param {string} id The identifier (uuid) of the image.
         * @param {string} dataUri The path of the image file relative to the specified data source location.
         * @param {File} file The image file. Should be passed to update the file referenced by the dataUri.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerUpdate: async (id: string, dataUri: string, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagesControllerUpdate', 'id', id)
            // verify required parameter 'dataUri' is not null or undefined
            assertParamExists('imagesControllerUpdate', 'dataUri', dataUri)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('imagesControllerUpdate', 'file', file)
            const localVarPath = `/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (dataUri !== undefined) { 
                localVarFormParams.append('dataUri', dataUri as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImagesApi - functional programming interface
 * @export
 */
export const ImagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new image and returns it. Additionally it saves the optional file passed to this endpoint under the image\'s dataUri. An error will be thrown if the referenced dataset does not exist. Trying to create an image with the same data URI as an already existing image will also result in an error.
         * @summary 
         * @param {string} dataset The identifier of the dataset (uuid) that the image will belong to.
         * @param {string} dataUri The path of the image file relative to the specified data source location.
         * @param {File} file The image file. Should be passed if the file is not already present in the data source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerCreate(dataset: string, dataUri: string, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerCreate(dataset, dataUri, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of all available images. If there do not exist any images it will return an empty array. If a dataset or job is specified, it will return all images in the dataset or used by the job. If the dataset or job does not exist it will return an empty array.
         * @summary 
         * @param {string} [dataset] The dataset identifier (uuid) to filter the images by.
         * @param {string} [job] The job identifier (uuid) to filter the images by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerFindAll(dataset?: string, job?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Image>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerFindAll(dataset, job, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves an image, if a valid identifier was provided. Otherwise it returns an error.
         * @summary 
         * @param {string} id The identifier (uuid) of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the file for an image.
         * @summary 
         * @param {string} id The identifier (uuid) of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerGetFile(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerGetFile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes an image and associated annotations permanently. It cannot be undone. It returns an error if the image can not be found or the delete operation fails.
         * @summary 
         * @param {string} id The identifier (uuid) of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerRemove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes all selected images and all associated annotations permanently. It cannot be undone. It returns the images that were deleted.
         * @summary 
         * @param {DeleteAllDto} deleteAllDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerRemoveAll(deleteAllDto: DeleteAllDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerRemoveAll(deleteAllDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the specified image by setting the values of the parameters passed. Additionally it saves the optional file passed to this endpoint under the image\'s (new) dataUri. It returns the updated image, if the update operation succeeds. It returns an error when trying to set the image data URI to an already existing image data URI. When changing the dataUri, the old file won\'t be deleted automatically.
         * @summary 
         * @param {string} id The identifier (uuid) of the image.
         * @param {string} dataUri The path of the image file relative to the specified data source location.
         * @param {File} file The image file. Should be passed to update the file referenced by the dataUri.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerUpdate(id: string, dataUri: string, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerUpdate(id, dataUri, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImagesApi - factory interface
 * @export
 */
export const ImagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImagesApiFp(configuration)
    return {
        /**
         * Creates a new image and returns it. Additionally it saves the optional file passed to this endpoint under the image\'s dataUri. An error will be thrown if the referenced dataset does not exist. Trying to create an image with the same data URI as an already existing image will also result in an error.
         * @summary 
         * @param {string} dataset The identifier of the dataset (uuid) that the image will belong to.
         * @param {string} dataUri The path of the image file relative to the specified data source location.
         * @param {File} file The image file. Should be passed if the file is not already present in the data source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerCreate(dataset: string, dataUri: string, file: File, options?: any): AxiosPromise<Image> {
            return localVarFp.imagesControllerCreate(dataset, dataUri, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all available images. If there do not exist any images it will return an empty array. If a dataset or job is specified, it will return all images in the dataset or used by the job. If the dataset or job does not exist it will return an empty array.
         * @summary 
         * @param {string} [dataset] The dataset identifier (uuid) to filter the images by.
         * @param {string} [job] The job identifier (uuid) to filter the images by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerFindAll(dataset?: string, job?: string, options?: any): AxiosPromise<Array<Image>> {
            return localVarFp.imagesControllerFindAll(dataset, job, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves an image, if a valid identifier was provided. Otherwise it returns an error.
         * @summary 
         * @param {string} id The identifier (uuid) of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerFindOne(id: string, options?: any): AxiosPromise<Image> {
            return localVarFp.imagesControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the file for an image.
         * @summary 
         * @param {string} id The identifier (uuid) of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerGetFile(id: string, options?: any): AxiosPromise<File> {
            return localVarFp.imagesControllerGetFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an image and associated annotations permanently. It cannot be undone. It returns an error if the image can not be found or the delete operation fails.
         * @summary 
         * @param {string} id The identifier (uuid) of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.imagesControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes all selected images and all associated annotations permanently. It cannot be undone. It returns the images that were deleted.
         * @summary 
         * @param {DeleteAllDto} deleteAllDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerRemoveAll(deleteAllDto: DeleteAllDto, options?: any): AxiosPromise<void> {
            return localVarFp.imagesControllerRemoveAll(deleteAllDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the specified image by setting the values of the parameters passed. Additionally it saves the optional file passed to this endpoint under the image\'s (new) dataUri. It returns the updated image, if the update operation succeeds. It returns an error when trying to set the image data URI to an already existing image data URI. When changing the dataUri, the old file won\'t be deleted automatically.
         * @summary 
         * @param {string} id The identifier (uuid) of the image.
         * @param {string} dataUri The path of the image file relative to the specified data source location.
         * @param {File} file The image file. Should be passed to update the file referenced by the dataUri.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerUpdate(id: string, dataUri: string, file: File, options?: any): AxiosPromise<Image> {
            return localVarFp.imagesControllerUpdate(id, dataUri, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImagesApi - object-oriented interface
 * @export
 * @class ImagesApi
 * @extends {BaseAPI}
 */
export class ImagesApi extends BaseAPI {
    /**
     * Creates a new image and returns it. Additionally it saves the optional file passed to this endpoint under the image\'s dataUri. An error will be thrown if the referenced dataset does not exist. Trying to create an image with the same data URI as an already existing image will also result in an error.
     * @summary 
     * @param {string} dataset The identifier of the dataset (uuid) that the image will belong to.
     * @param {string} dataUri The path of the image file relative to the specified data source location.
     * @param {File} file The image file. Should be passed if the file is not already present in the data source.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerCreate(dataset: string, dataUri: string, file: File, options?: AxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerCreate(dataset, dataUri, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all available images. If there do not exist any images it will return an empty array. If a dataset or job is specified, it will return all images in the dataset or used by the job. If the dataset or job does not exist it will return an empty array.
     * @summary 
     * @param {string} [dataset] The dataset identifier (uuid) to filter the images by.
     * @param {string} [job] The job identifier (uuid) to filter the images by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerFindAll(dataset?: string, job?: string, options?: AxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerFindAll(dataset, job, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves an image, if a valid identifier was provided. Otherwise it returns an error.
     * @summary 
     * @param {string} id The identifier (uuid) of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerFindOne(id: string, options?: AxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the file for an image.
     * @summary 
     * @param {string} id The identifier (uuid) of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerGetFile(id: string, options?: AxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerGetFile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an image and associated annotations permanently. It cannot be undone. It returns an error if the image can not be found or the delete operation fails.
     * @summary 
     * @param {string} id The identifier (uuid) of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerRemove(id: string, options?: AxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes all selected images and all associated annotations permanently. It cannot be undone. It returns the images that were deleted.
     * @summary 
     * @param {DeleteAllDto} deleteAllDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerRemoveAll(deleteAllDto: DeleteAllDto, options?: AxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerRemoveAll(deleteAllDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the specified image by setting the values of the parameters passed. Additionally it saves the optional file passed to this endpoint under the image\'s (new) dataUri. It returns the updated image, if the update operation succeeds. It returns an error when trying to set the image data URI to an already existing image data URI. When changing the dataUri, the old file won\'t be deleted automatically.
     * @summary 
     * @param {string} id The identifier (uuid) of the image.
     * @param {string} dataUri The path of the image file relative to the specified data source location.
     * @param {File} file The image file. Should be passed to update the file referenced by the dataUri.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerUpdate(id: string, dataUri: string, file: File, options?: AxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerUpdate(id, dataUri, file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobsApi - axios parameter creator
 * @export
 */
export const JobsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new job and returns it. The created job is automatically added to the job queue. Referenced images can belong to different datasets, however these datasets must all belong to the same project. An error will be thrown if the referenced model, project or some of the referenced images do not exist.
         * @summary 
         * @param {CreateJobDto} createJobDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsControllerCreate: async (createJobDto: CreateJobDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createJobDto' is not null or undefined
            assertParamExists('jobsControllerCreate', 'createJobDto', createJobDto)
            const localVarPath = `/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createJobDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all available jobs. If there do not exist any jobs it will return an empty array. If a project is specified, it will return all jobs belonging to that project. If the project does not exist, it will return an empty array as well.
         * @summary 
         * @param {string} [project] The project identifier (uuid) to filter the jobs by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsControllerFindAll: async (project?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (project !== undefined) {
                localVarQueryParameter['project'] = project;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a job, if a valid identifier was provided. Otherwise it returns an error.
         * @summary 
         * @param {string} id The identifier (uuid) of the job.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('jobsControllerFindOne', 'id', id)
            const localVarPath = `/jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the log file for a job.
         * @summary 
         * @param {string} id The identifier (uuid) of the job.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsControllerGetFile: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('jobsControllerGetFile', 'id', id)
            const localVarPath = `/jobs/{id}/log-file`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the annotation progress of a job. If the job does not exist, it will return an error.
         * @summary 
         * @param {string} id The identifier (uuid) of the job.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsControllerProgress: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('jobsControllerProgress', 'id', id)
            const localVarPath = `/jobs/{id}/progress`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a job and associated annotations permanently. It cannot be undone. It returns an error if the job can not be found or the delete operation fails.
         * @summary 
         * @param {string} id The identifier (uuid) of the job.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsControllerRemove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('jobsControllerRemove', 'id', id)
            const localVarPath = `/jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all selected jobs and associated annotations permanently. It cannot be undone. It returns the jobs that were deleted.
         * @summary 
         * @param {DeleteAllDto} deleteAllDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsControllerRemoveAll: async (deleteAllDto: DeleteAllDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteAllDto' is not null or undefined
            assertParamExists('jobsControllerRemoveAll', 'deleteAllDto', deleteAllDto)
            const localVarPath = `/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteAllDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the specified job by setting the values of the parameters passed. All parameters not provided will be left unchanged. It returns the updated job, if the update operation succeeds. It returns an error, if a valid order of status transitions was not followed.
         * @summary 
         * @param {string} id The identifier (uuid) of the job.
         * @param {JobsControllerUpdateStatusEnum} [status] The new status of the job. By default, a job is in status &#x60;queued&#x60;. A valid order of transitions is enforced. For example, when the job is in status &#x60;queued&#x60;, it can only be updated to &#x60;running&#x60;, &#x60;failed&#x60; or &#x60;canceled&#x60;. From status &#x60;running&#x60;, it can only be updated to &#x60;succeeded&#x60;, &#x60;failed&#x60; or &#x60;canceled&#x60;.
         * @param {File} [file] The job log .txt file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsControllerUpdate: async (id: string, status?: JobsControllerUpdateStatusEnum, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('jobsControllerUpdate', 'id', id)
            const localVarPath = `/jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (status !== undefined) { 
                localVarFormParams.append('status', status as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobsApi - functional programming interface
 * @export
 */
export const JobsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new job and returns it. The created job is automatically added to the job queue. Referenced images can belong to different datasets, however these datasets must all belong to the same project. An error will be thrown if the referenced model, project or some of the referenced images do not exist.
         * @summary 
         * @param {CreateJobDto} createJobDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsControllerCreate(createJobDto: CreateJobDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsControllerCreate(createJobDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of all available jobs. If there do not exist any jobs it will return an empty array. If a project is specified, it will return all jobs belonging to that project. If the project does not exist, it will return an empty array as well.
         * @summary 
         * @param {string} [project] The project identifier (uuid) to filter the jobs by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsControllerFindAll(project?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Job>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsControllerFindAll(project, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a job, if a valid identifier was provided. Otherwise it returns an error.
         * @summary 
         * @param {string} id The identifier (uuid) of the job.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the log file for a job.
         * @summary 
         * @param {string} id The identifier (uuid) of the job.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsControllerGetFile(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsControllerGetFile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the annotation progress of a job. If the job does not exist, it will return an error.
         * @summary 
         * @param {string} id The identifier (uuid) of the job.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsControllerProgress(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Progress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsControllerProgress(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a job and associated annotations permanently. It cannot be undone. It returns an error if the job can not be found or the delete operation fails.
         * @summary 
         * @param {string} id The identifier (uuid) of the job.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsControllerRemove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsControllerRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes all selected jobs and associated annotations permanently. It cannot be undone. It returns the jobs that were deleted.
         * @summary 
         * @param {DeleteAllDto} deleteAllDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsControllerRemoveAll(deleteAllDto: DeleteAllDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsControllerRemoveAll(deleteAllDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the specified job by setting the values of the parameters passed. All parameters not provided will be left unchanged. It returns the updated job, if the update operation succeeds. It returns an error, if a valid order of status transitions was not followed.
         * @summary 
         * @param {string} id The identifier (uuid) of the job.
         * @param {JobsControllerUpdateStatusEnum} [status] The new status of the job. By default, a job is in status &#x60;queued&#x60;. A valid order of transitions is enforced. For example, when the job is in status &#x60;queued&#x60;, it can only be updated to &#x60;running&#x60;, &#x60;failed&#x60; or &#x60;canceled&#x60;. From status &#x60;running&#x60;, it can only be updated to &#x60;succeeded&#x60;, &#x60;failed&#x60; or &#x60;canceled&#x60;.
         * @param {File} [file] The job log .txt file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsControllerUpdate(id: string, status?: JobsControllerUpdateStatusEnum, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsControllerUpdate(id, status, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobsApi - factory interface
 * @export
 */
export const JobsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobsApiFp(configuration)
    return {
        /**
         * Creates a new job and returns it. The created job is automatically added to the job queue. Referenced images can belong to different datasets, however these datasets must all belong to the same project. An error will be thrown if the referenced model, project or some of the referenced images do not exist.
         * @summary 
         * @param {CreateJobDto} createJobDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsControllerCreate(createJobDto: CreateJobDto, options?: any): AxiosPromise<Job> {
            return localVarFp.jobsControllerCreate(createJobDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all available jobs. If there do not exist any jobs it will return an empty array. If a project is specified, it will return all jobs belonging to that project. If the project does not exist, it will return an empty array as well.
         * @summary 
         * @param {string} [project] The project identifier (uuid) to filter the jobs by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsControllerFindAll(project?: string, options?: any): AxiosPromise<Array<Job>> {
            return localVarFp.jobsControllerFindAll(project, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a job, if a valid identifier was provided. Otherwise it returns an error.
         * @summary 
         * @param {string} id The identifier (uuid) of the job.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsControllerFindOne(id: string, options?: any): AxiosPromise<Job> {
            return localVarFp.jobsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the log file for a job.
         * @summary 
         * @param {string} id The identifier (uuid) of the job.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsControllerGetFile(id: string, options?: any): AxiosPromise<File> {
            return localVarFp.jobsControllerGetFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the annotation progress of a job. If the job does not exist, it will return an error.
         * @summary 
         * @param {string} id The identifier (uuid) of the job.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsControllerProgress(id: string, options?: any): AxiosPromise<Progress> {
            return localVarFp.jobsControllerProgress(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a job and associated annotations permanently. It cannot be undone. It returns an error if the job can not be found or the delete operation fails.
         * @summary 
         * @param {string} id The identifier (uuid) of the job.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.jobsControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes all selected jobs and associated annotations permanently. It cannot be undone. It returns the jobs that were deleted.
         * @summary 
         * @param {DeleteAllDto} deleteAllDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsControllerRemoveAll(deleteAllDto: DeleteAllDto, options?: any): AxiosPromise<void> {
            return localVarFp.jobsControllerRemoveAll(deleteAllDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the specified job by setting the values of the parameters passed. All parameters not provided will be left unchanged. It returns the updated job, if the update operation succeeds. It returns an error, if a valid order of status transitions was not followed.
         * @summary 
         * @param {string} id The identifier (uuid) of the job.
         * @param {JobsControllerUpdateStatusEnum} [status] The new status of the job. By default, a job is in status &#x60;queued&#x60;. A valid order of transitions is enforced. For example, when the job is in status &#x60;queued&#x60;, it can only be updated to &#x60;running&#x60;, &#x60;failed&#x60; or &#x60;canceled&#x60;. From status &#x60;running&#x60;, it can only be updated to &#x60;succeeded&#x60;, &#x60;failed&#x60; or &#x60;canceled&#x60;.
         * @param {File} [file] The job log .txt file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsControllerUpdate(id: string, status?: JobsControllerUpdateStatusEnum, file?: File, options?: any): AxiosPromise<Job> {
            return localVarFp.jobsControllerUpdate(id, status, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobsApi - object-oriented interface
 * @export
 * @class JobsApi
 * @extends {BaseAPI}
 */
export class JobsApi extends BaseAPI {
    /**
     * Creates a new job and returns it. The created job is automatically added to the job queue. Referenced images can belong to different datasets, however these datasets must all belong to the same project. An error will be thrown if the referenced model, project or some of the referenced images do not exist.
     * @summary 
     * @param {CreateJobDto} createJobDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public jobsControllerCreate(createJobDto: CreateJobDto, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).jobsControllerCreate(createJobDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all available jobs. If there do not exist any jobs it will return an empty array. If a project is specified, it will return all jobs belonging to that project. If the project does not exist, it will return an empty array as well.
     * @summary 
     * @param {string} [project] The project identifier (uuid) to filter the jobs by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public jobsControllerFindAll(project?: string, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).jobsControllerFindAll(project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a job, if a valid identifier was provided. Otherwise it returns an error.
     * @summary 
     * @param {string} id The identifier (uuid) of the job.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public jobsControllerFindOne(id: string, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).jobsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the log file for a job.
     * @summary 
     * @param {string} id The identifier (uuid) of the job.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public jobsControllerGetFile(id: string, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).jobsControllerGetFile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the annotation progress of a job. If the job does not exist, it will return an error.
     * @summary 
     * @param {string} id The identifier (uuid) of the job.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public jobsControllerProgress(id: string, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).jobsControllerProgress(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a job and associated annotations permanently. It cannot be undone. It returns an error if the job can not be found or the delete operation fails.
     * @summary 
     * @param {string} id The identifier (uuid) of the job.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public jobsControllerRemove(id: string, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).jobsControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes all selected jobs and associated annotations permanently. It cannot be undone. It returns the jobs that were deleted.
     * @summary 
     * @param {DeleteAllDto} deleteAllDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public jobsControllerRemoveAll(deleteAllDto: DeleteAllDto, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).jobsControllerRemoveAll(deleteAllDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the specified job by setting the values of the parameters passed. All parameters not provided will be left unchanged. It returns the updated job, if the update operation succeeds. It returns an error, if a valid order of status transitions was not followed.
     * @summary 
     * @param {string} id The identifier (uuid) of the job.
     * @param {JobsControllerUpdateStatusEnum} [status] The new status of the job. By default, a job is in status &#x60;queued&#x60;. A valid order of transitions is enforced. For example, when the job is in status &#x60;queued&#x60;, it can only be updated to &#x60;running&#x60;, &#x60;failed&#x60; or &#x60;canceled&#x60;. From status &#x60;running&#x60;, it can only be updated to &#x60;succeeded&#x60;, &#x60;failed&#x60; or &#x60;canceled&#x60;.
     * @param {File} [file] The job log .txt file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public jobsControllerUpdate(id: string, status?: JobsControllerUpdateStatusEnum, file?: File, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).jobsControllerUpdate(id, status, file, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const JobsControllerUpdateStatusEnum = {
    Queued: 'queued',
    Running: 'running',
    Succeeded: 'succeeded',
    Failed: 'failed',
    Canceled: 'canceled'
} as const;
export type JobsControllerUpdateStatusEnum = typeof JobsControllerUpdateStatusEnum[keyof typeof JobsControllerUpdateStatusEnum];


/**
 * ModelVersionsApi - axios parameter creator
 * @export
 */
export const ModelVersionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of all available models and their versions. If no model versions are available, it returns an empty array.
         * @summary 
         * @param {Array<string>} [versionTags] Key value pair of a model version tag which can be specified as &#x60;versionTags[key]&#x3D;value&#x60;. Filtering by multiple tags is possible by chaining key value pairs with &#x60;versionTags[modality]&#x3D;T2&amp;versionTags[bodypart]&#x3D;Abdomen&#x60;. If at least one version tag in an invalid format is provided, it returns an error.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelsControllerFindAll: async (versionTags?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/model-versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionTags) {
                localVarQueryParameter['versionTags'] = versionTags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a model, if a valid name and version was provided. Otherwise it returns an error.
         * @summary 
         * @param {string} name The name of the model.
         * @param {string} version The version of the model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelsControllerFindVersion: async (name: string, version: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('modelsControllerFindVersion', 'name', name)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('modelsControllerFindVersion', 'version', version)
            const localVarPath = `/model-versions/{name}/{version}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModelVersionsApi - functional programming interface
 * @export
 */
export const ModelVersionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModelVersionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of all available models and their versions. If no model versions are available, it returns an empty array.
         * @summary 
         * @param {Array<string>} [versionTags] Key value pair of a model version tag which can be specified as &#x60;versionTags[key]&#x3D;value&#x60;. Filtering by multiple tags is possible by chaining key value pairs with &#x60;versionTags[modality]&#x3D;T2&amp;versionTags[bodypart]&#x3D;Abdomen&#x60;. If at least one version tag in an invalid format is provided, it returns an error.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modelsControllerFindAll(versionTags?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelVersion>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modelsControllerFindAll(versionTags, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a model, if a valid name and version was provided. Otherwise it returns an error.
         * @summary 
         * @param {string} name The name of the model.
         * @param {string} version The version of the model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modelsControllerFindVersion(name: string, version: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modelsControllerFindVersion(name, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ModelVersionsApi - factory interface
 * @export
 */
export const ModelVersionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModelVersionsApiFp(configuration)
    return {
        /**
         * Retrieves a list of all available models and their versions. If no model versions are available, it returns an empty array.
         * @summary 
         * @param {Array<string>} [versionTags] Key value pair of a model version tag which can be specified as &#x60;versionTags[key]&#x3D;value&#x60;. Filtering by multiple tags is possible by chaining key value pairs with &#x60;versionTags[modality]&#x3D;T2&amp;versionTags[bodypart]&#x3D;Abdomen&#x60;. If at least one version tag in an invalid format is provided, it returns an error.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelsControllerFindAll(versionTags?: Array<string>, options?: any): AxiosPromise<Array<ModelVersion>> {
            return localVarFp.modelsControllerFindAll(versionTags, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a model, if a valid name and version was provided. Otherwise it returns an error.
         * @summary 
         * @param {string} name The name of the model.
         * @param {string} version The version of the model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelsControllerFindVersion(name: string, version: string, options?: any): AxiosPromise<ModelVersion> {
            return localVarFp.modelsControllerFindVersion(name, version, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModelVersionsApi - object-oriented interface
 * @export
 * @class ModelVersionsApi
 * @extends {BaseAPI}
 */
export class ModelVersionsApi extends BaseAPI {
    /**
     * Retrieves a list of all available models and their versions. If no model versions are available, it returns an empty array.
     * @summary 
     * @param {Array<string>} [versionTags] Key value pair of a model version tag which can be specified as &#x60;versionTags[key]&#x3D;value&#x60;. Filtering by multiple tags is possible by chaining key value pairs with &#x60;versionTags[modality]&#x3D;T2&amp;versionTags[bodypart]&#x3D;Abdomen&#x60;. If at least one version tag in an invalid format is provided, it returns an error.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelVersionsApi
     */
    public modelsControllerFindAll(versionTags?: Array<string>, options?: AxiosRequestConfig) {
        return ModelVersionsApiFp(this.configuration).modelsControllerFindAll(versionTags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a model, if a valid name and version was provided. Otherwise it returns an error.
     * @summary 
     * @param {string} name The name of the model.
     * @param {string} version The version of the model.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelVersionsApi
     */
    public modelsControllerFindVersion(name: string, version: string, options?: AxiosRequestConfig) {
        return ModelVersionsApiFp(this.configuration).modelsControllerFindVersion(name, version, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new project and returns it.
         * @summary 
         * @param {CreateProjectDto} createProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerCreate: async (createProjectDto: CreateProjectDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProjectDto' is not null or undefined
            assertParamExists('projectsControllerCreate', 'createProjectDto', createProjectDto)
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProjectDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all available projects. If there are no projects it will return an empty array.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerFindAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a project, if a valid identifier was provided. Otherwise it returns an error.
         * @summary 
         * @param {string} id The identifier (uuid) of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsControllerFindOne', 'id', id)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a project and all associated jobs, datasets, images and annotations permanently. It cannot be undone. It returns an error if the project can not be found or the delete operation fails.
         * @summary 
         * @param {string} id The identifier (uuid) of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerRemove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsControllerRemove', 'id', id)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all selected projects and their associated jobs, datasets, images and annotations permanently. It cannot be undone. It returns the project that were deleted.
         * @summary 
         * @param {DeleteAllDto} deleteAllDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerRemoveAll: async (deleteAllDto: DeleteAllDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteAllDto' is not null or undefined
            assertParamExists('projectsControllerRemoveAll', 'deleteAllDto', deleteAllDto)
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteAllDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the specified project by setting the values of the parameters passed. It returns the updated project, if the update operation succeeds. Otherwise it returns an error.
         * @summary 
         * @param {string} id The identifier (uuid) of the project.
         * @param {UpdateProjectDto} updateProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerUpdate: async (id: string, updateProjectDto: UpdateProjectDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsControllerUpdate', 'id', id)
            // verify required parameter 'updateProjectDto' is not null or undefined
            assertParamExists('projectsControllerUpdate', 'updateProjectDto', updateProjectDto)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProjectDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new project and returns it.
         * @summary 
         * @param {CreateProjectDto} createProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsControllerCreate(createProjectDto: CreateProjectDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsControllerCreate(createProjectDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of all available projects. If there are no projects it will return an empty array.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsControllerFindAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Project>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsControllerFindAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a project, if a valid identifier was provided. Otherwise it returns an error.
         * @summary 
         * @param {string} id The identifier (uuid) of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a project and all associated jobs, datasets, images and annotations permanently. It cannot be undone. It returns an error if the project can not be found or the delete operation fails.
         * @summary 
         * @param {string} id The identifier (uuid) of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsControllerRemove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsControllerRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes all selected projects and their associated jobs, datasets, images and annotations permanently. It cannot be undone. It returns the project that were deleted.
         * @summary 
         * @param {DeleteAllDto} deleteAllDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsControllerRemoveAll(deleteAllDto: DeleteAllDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsControllerRemoveAll(deleteAllDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the specified project by setting the values of the parameters passed. It returns the updated project, if the update operation succeeds. Otherwise it returns an error.
         * @summary 
         * @param {string} id The identifier (uuid) of the project.
         * @param {UpdateProjectDto} updateProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsControllerUpdate(id: string, updateProjectDto: UpdateProjectDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsControllerUpdate(id, updateProjectDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * Creates a new project and returns it.
         * @summary 
         * @param {CreateProjectDto} createProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerCreate(createProjectDto: CreateProjectDto, options?: any): AxiosPromise<Project> {
            return localVarFp.projectsControllerCreate(createProjectDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all available projects. If there are no projects it will return an empty array.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerFindAll(options?: any): AxiosPromise<Array<Project>> {
            return localVarFp.projectsControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a project, if a valid identifier was provided. Otherwise it returns an error.
         * @summary 
         * @param {string} id The identifier (uuid) of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerFindOne(id: string, options?: any): AxiosPromise<Project> {
            return localVarFp.projectsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a project and all associated jobs, datasets, images and annotations permanently. It cannot be undone. It returns an error if the project can not be found or the delete operation fails.
         * @summary 
         * @param {string} id The identifier (uuid) of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.projectsControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes all selected projects and their associated jobs, datasets, images and annotations permanently. It cannot be undone. It returns the project that were deleted.
         * @summary 
         * @param {DeleteAllDto} deleteAllDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerRemoveAll(deleteAllDto: DeleteAllDto, options?: any): AxiosPromise<void> {
            return localVarFp.projectsControllerRemoveAll(deleteAllDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the specified project by setting the values of the parameters passed. It returns the updated project, if the update operation succeeds. Otherwise it returns an error.
         * @summary 
         * @param {string} id The identifier (uuid) of the project.
         * @param {UpdateProjectDto} updateProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerUpdate(id: string, updateProjectDto: UpdateProjectDto, options?: any): AxiosPromise<Project> {
            return localVarFp.projectsControllerUpdate(id, updateProjectDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * Creates a new project and returns it.
     * @summary 
     * @param {CreateProjectDto} createProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsControllerCreate(createProjectDto: CreateProjectDto, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsControllerCreate(createProjectDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all available projects. If there are no projects it will return an empty array.
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsControllerFindAll(options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a project, if a valid identifier was provided. Otherwise it returns an error.
     * @summary 
     * @param {string} id The identifier (uuid) of the project.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsControllerFindOne(id: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a project and all associated jobs, datasets, images and annotations permanently. It cannot be undone. It returns an error if the project can not be found or the delete operation fails.
     * @summary 
     * @param {string} id The identifier (uuid) of the project.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsControllerRemove(id: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes all selected projects and their associated jobs, datasets, images and annotations permanently. It cannot be undone. It returns the project that were deleted.
     * @summary 
     * @param {DeleteAllDto} deleteAllDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsControllerRemoveAll(deleteAllDto: DeleteAllDto, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsControllerRemoveAll(deleteAllDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the specified project by setting the values of the parameters passed. It returns the updated project, if the update operation succeeds. Otherwise it returns an error.
     * @summary 
     * @param {string} id The identifier (uuid) of the project.
     * @param {UpdateProjectDto} updateProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsControllerUpdate(id: string, updateProjectDto: UpdateProjectDto, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsControllerUpdate(id, updateProjectDto, options).then((request) => request(this.axios, this.basePath));
    }
}



